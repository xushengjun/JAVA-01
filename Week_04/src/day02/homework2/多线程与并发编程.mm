<map version="1.0.1"><node CREATED="1612582836894" ID="ID_root" MODIFIED="1612582836894" TEXT="多线程与并发编程"><node CREATED="1612582836894" ID="ID_9eebdc1067e7" POSITION="right" MODIFIED="1612582836894" TEXT="多线程基础"><node CREATED="1612582836894" ID="ID_eaf38217b6a5" MODIFIED="1612582836894" TEXT="线程与进程的概念和区别"><richcontent TYPE="NOTE"><html><head></head><body><p>进程：正在运行的程序，系统资源调度的独立单元。
线程：CPU资源调度单元</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_e5d73eefd813" MODIFIED="1612582836894" TEXT="多核与多线程的关系"><richcontent TYPE="NOTE"><html><head></head><body><p>多核，指的是多个cpu内核
多线程，单线程的程序只有一条执行路径；多线程的程序有多条执行路径，</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_01fca7a65dcf" MODIFIED="1612582836894" TEXT="并发、并行、串行"><richcontent TYPE="NOTE"><html><head></head><body><p>并发：多个线程同时在一个CPU内核上争夺CPU时间片执行。
并行：多个线程分别在不同的CPU内核上执行。
串行：多个线程排队在同一个CPU内核上执行。
</p></body></html></richcontent></node></node><node CREATED="1612582836894" ID="ID_643731c1acd0" POSITION="right" MODIFIED="1612582836894" TEXT="java多线程"><node CREATED="1612582836894" ID="ID_ed55a4c554dc" MODIFIED="1612582836894" TEXT="守护线程"><richcontent TYPE="NOTE"><html><head></head><body><p>线程分为守护线程和用户线程。
守护线程是用户线程的“保姆”，当所有用户线程退出后，守护线程才能退出。
java中的垃圾回收线程就是典型的守护线程。</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_525269a06632" MODIFIED="1612582836894" TEXT="线程对象"><node CREATED="1612582836894" ID="ID_8320eb409838" MODIFIED="1612582836894" TEXT="线程对象"><node CREATED="1612582836894" ID="ID_00101d8516c0" MODIFIED="1612582836894" TEXT="Thread"><richcontent TYPE="NOTE"><html><head></head><body><p>线程对象，实现了Runable接口
有一个无参构造方法和有参构造方法，后者接收一个实现了Runable的对象。


调用start方法，线程进入可运行状态</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_504101892645" MODIFIED="1612582836894" TEXT="CompletableFuture"><richcontent TYPE="NOTE"><html><head></head><body><p>future是一个未来对象，执行的过程可以异步，但是get获得结果是阻塞的。

如果想要拿到结果，拿到后对结果进行处理，这个过程不用等待，主线程可以一直往下执行，CompletableFuture使一切变得可能。
</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_abd90a554277" MODIFIED="1612582836894" TEXT="FutureTask"><richcontent TYPE="NOTE"><html><head></head><body><p>搭配Thread，可获取执行结果的异步线程类</p></body></html></richcontent></node></node><node CREATED="1612582836894" ID="ID_f71a795f41a5" MODIFIED="1612582836894" TEXT="线程执行接口"><node CREATED="1612582836894" ID="ID_34520bae8f3d" MODIFIED="1612582836894" TEXT="Runnable"><richcontent TYPE="NOTE"><html><head></head><body><p>相对于Runnable，
run方法有返回值，且能在主线程捕获run方法中抛出的异常</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_9589db6f080a" MODIFIED="1612582836894" TEXT="Callable"><richcontent TYPE="NOTE"><html><head></head><body><p>run方法有返回值，且能在主线程捕获run方法中抛出的异常</p></body></html></richcontent></node></node><node CREATED="1612582836894" ID="ID_92f22aa5cc4c" MODIFIED="1612582836894" TEXT="线程返回结果接口"><node CREATED="1612582836894" ID="ID_ae454068d33f" MODIFIED="1612582836894" TEXT="Future"><richcontent TYPE="NOTE"><html><head></head><body><p>封装任务执行情况的获取
cancel()，取消
isCancel()，是否取消
isDone()，是否执行完成
get()，获取执行结果
并提供了一个限时获取执行结果的方法

Future和Callable是搭配一起使用的</p></body></html></richcontent></node></node><node CREATED="1612582836894" ID="ID_4bca31aeac18" MODIFIED="1612582836894" TEXT="使用"><node CREATED="1612582836894" ID="ID_84ad13873e01" MODIFIED="1612582836894" TEXT="非线程池"><richcontent TYPE="NOTE"><html><head></head><body><p>Thread只能接收一个Runnable接口</p></body></html></richcontent><node CREATED="1612582836894" ID="ID_d8c6dc6054a4" MODIFIED="1612582836894" TEXT="Thread+Runnable"></node><node CREATED="1612582836894" ID="ID_32e33daffe4c" MODIFIED="1612582836894" TEXT="Thread+FutureTask"></node></node><node CREATED="1612582836894" ID="ID_22fc690a7015" MODIFIED="1612582836894" TEXT="线程池"><node CREATED="1612582836894" ID="ID_4a5f3f73b15e" MODIFIED="1612582836894" TEXT="Excutor+callable"></node></node></node></node><node CREATED="1612582836894" ID="ID_b0aaf8ca777e" MODIFIED="1612582836894" TEXT="线程安全"></node><node CREATED="1612582836894" ID="ID_f667d8a4b2b1" MODIFIED="1612582836894" TEXT="java并发包"><node CREATED="1612582836894" ID="ID_661dc00bbb7f" MODIFIED="1612582836894" TEXT="锁"><node CREATED="1612582836894" ID="ID_88ee46d9c58c" MODIFIED="1612582836894" TEXT="synchonized、wait、notify\notifyall"></node><node CREATED="1612582836894" ID="ID_6f37a85757bd" MODIFIED="1612582836894" TEXT="lock"><node CREATED="1612582836894" ID="ID_ed291bc670b6" MODIFIED="1612582836894" TEXT="ReentrantLock、Condition"><richcontent TYPE="NOTE"><html><head></head><body><p>ReentrantLock、Condition的搭配，类似
synchonized和wait、notify\notifyall</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_0b3d9f2316ad" MODIFIED="1612582836894" TEXT="可重入读写锁"></node></node><node CREATED="1612582836894" ID="ID_3ab66c84e2c1" MODIFIED="1612582836894" TEXT="LockSupport"><richcontent TYPE="NOTE"><html><head></head><body><p>类似Thread类的静态方法类，锁当前线程</p></body></html></richcontent></node></node><node CREATED="1612582836894" ID="ID_dd9375b5990e" MODIFIED="1612582836894" TEXT="并发工具类"><node CREATED="1612582836894" ID="ID_d2d3e49ba552" MODIFIED="1612582836894" TEXT="CountDownLatch"></node><node CREATED="1612582836894" ID="ID_10ccf1e9b846" MODIFIED="1612582836894" TEXT="CyclicBarrier"></node><node CREATED="1612582836894" ID="ID_7ce5426c277d" MODIFIED="1612582836894" TEXT="Semaphore"></node><node CREATED="1612582836894" ID="ID_90a6d5500ca4" MODIFIED="1612582836894" TEXT="出现背景"><richcontent TYPE="NOTE"><html><head></head><body><p>更复杂的应用场景，比如
- 我们需要控制实际并发访问资源的并发数量
- 我们需要多个线程在某个时间同时开始运行
- 我们需要指定数量线程到达某个状态再继续处理</p></body></html></richcontent></node></node><node CREATED="1612582836894" ID="ID_9a0b196475f7" MODIFIED="1612582836894" TEXT="原子类"><node CREATED="1612582836894" ID="ID_b897c1a89f01" MODIFIED="1612582836894" TEXT="AtomicInteger"></node><node CREATED="1612582836894" ID="ID_e512d712d1f6" MODIFIED="1612582836894" TEXT="AtomicLong"></node><node CREATED="1612582836894" ID="ID_c81b71f21076" MODIFIED="1612582836894" TEXT="LongAdder"></node><node CREATED="1612582836894" ID="ID_7762b1697960" MODIFIED="1612582836894" TEXT="？原理"><richcontent TYPE="NOTE"><html><head></head><body><p>核心实现原理：
1、volatile 保证读写操作都可见（注意不保证原子）；
2、使用 CAS 指令，作为乐观锁实现，通过自旋重试保证写入。</p></body></html></richcontent></node></node><node CREATED="1612582836894" ID="ID_fc279d3a20e5" MODIFIED="1612582836894" TEXT="线程池"><node CREATED="1612582836894" ID="ID_adc1b2acd0d2" MODIFIED="1612582836894" TEXT="继承结构"><richcontent TYPE="NOTE"><html><head></head><body><p>ThreadPoolExcutor--&amp;gt;AbstractExcutorService
--&amp;gt;ExcutorService--&amp;gt;Excutor
</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_e939672195dd" MODIFIED="1612582836894" TEXT="重要属性"><richcontent TYPE="NOTE"><html><head></head><body><p>corePoolSize：核心线程池大小
workQueue：任务队列
maximumPoolSize：最大线程池大小
拒绝策略：</p></body></html></richcontent><node CREATED="1612582836894" ID="ID_4de747027f5a" MODIFIED="1612582836894" TEXT="corePoolSize"><richcontent TYPE="NOTE"><html><head></head><body><p>核心线程池大小</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_fdf617cca966" MODIFIED="1612582836894" TEXT="workQueue"><richcontent TYPE="NOTE"><html><head></head><body><p>任务缓冲队列</p></body></html></richcontent><node CREATED="1612582836894" ID="ID_82deaa3e8c20" MODIFIED="1612582836894" TEXT="ArrayBlockingQueue"><richcontent TYPE="NOTE"><html><head></head><body><p>固定大小的任务队列，FIFO</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_6f6cfc5cf6cb" MODIFIED="1612582836894" TEXT="LinkedBlockingQueue"><richcontent TYPE="NOTE"><html><head></head><body><p>非固定大小的任务队列，FIFO</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_a16ee6c6b14a" MODIFIED="1612582836894" TEXT="PriorityBlockingQueue"><richcontent TYPE="NOTE"><html><head></head><body><p>跟LinkedBlockingQueue类似，但是内部对象的排序不是FIFO，而是对象的自然顺序或构造函数的Comparator</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_696a5fe17de4" MODIFIED="1612582836894" TEXT="SynchronizedQueue"><richcontent TYPE="NOTE"><html><head></head><body><p>对象的操作必须是放和取交替进行</p></body></html></richcontent></node></node><node CREATED="1612582836894" ID="ID_990c850e410b" MODIFIED="1612582836894" TEXT="maxmumPoolSize"><richcontent TYPE="NOTE"><html><head></head><body><p>最大线程池大小</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_356ff468e31b" MODIFIED="1612582836894" TEXT="拒绝策略"><node CREATED="1612582836894" ID="ID_7ba0f9d5b0e6" MODIFIED="1612582836894" TEXT="AbortPolicy"><richcontent TYPE="NOTE"><html><head></head><body><p>丢弃任务并抛出异常</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_268087121545" MODIFIED="1612582836894" TEXT="DiscardPolicy"><richcontent TYPE="NOTE"><html><head></head><body><p>丢弃任务，但是不抛出异常</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_193a455a5840" MODIFIED="1612582836894" TEXT="DiscardOldestPolicy"><richcontent TYPE="NOTE"><html><head></head><body><p>丢弃队列最前面的任务，然后重新提交被拒绝的任务</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_20c59dceccc9" MODIFIED="1612582836894" TEXT="CallerRunsPolicy"><richcontent TYPE="NOTE"><html><head></head><body><p>由调用线程执行处理该任务</p></body></html></richcontent></node></node></node><node CREATED="1612582836894" ID="ID_618d97ce9a69" MODIFIED="1612582836894" TEXT="执行方法"><node CREATED="1612582836894" ID="ID_4d0151342699" MODIFIED="1612582836894" TEXT="submit"><richcontent TYPE="NOTE"><html><head></head><body><p>有返回值，返回值用Future封装
异常可以用</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_5990318c87df" MODIFIED="1612582836894" TEXT="excute"><richcontent TYPE="NOTE"><html><head></head><body><p>无返回值，异常无法捕捉</p></body></html></richcontent></node></node><node CREATED="1612582836894" ID="ID_14f9cc955fd3" MODIFIED="1612582836894" TEXT="执行步骤"><richcontent TYPE="NOTE"><html><head></head><body><p>1.判断核心线程池大小
如果小于，创建线程执行。
如果大于，加入缓冲队列
当缓冲队列满了，跟最大线程池大小比较
2.如果小于最大线程池大小，创建新线程执行；
如果大于最大线程池大小，按照拒绝策略执行任务</p></body></html></richcontent></node><node CREATED="1612582836894" ID="ID_5c2ebc37c105" MODIFIED="1612582836894" TEXT="线程池大小设置经验"><richcontent TYPE="NOTE"><html><head></head><body><p>N为CPU核数
如果是IO密集型，设置为2N或2N+2；
如果是CPU密集型，设置为N或N+1</p></body></html></richcontent></node></node><node CREATED="1612582836894" ID="ID_d4a09a2a2e7a" MODIFIED="1612582836894" TEXT="集合类"><node CREATED="1612582836894" ID="ID_04c8e2c4c552" MODIFIED="1612582836894" TEXT="CopyOnWriteArrayList"></node><node CREATED="1612582836894" ID="ID_f3b2567c6232" MODIFIED="1612582836894" TEXT="ConcurrentMap"></node></node></node></node></node></map>