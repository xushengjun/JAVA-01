
并行GC
```
2015‐05‐26T14:27:41.155‐0200 : 116.356 : 
[ Full GC ( Ergonomics ) [PSYoungGen: 
1305132K‐>0K(2796544K)] [ ParOldGen : 
7133794K‐>6597672K (8388608K) ] 8438926K‐>6597672K (11185152K) , 
[Metaspace: 6745K‐>6745K(1056768K)] ,
 0.9158801 secs , [Times: user=4.49 sys=0.64, real=0.92 secs]
```
>. 0.9158801 secs – GC事件持续的时间,以秒为单位。 
> [Times: user=4.49 sys=0.64, real=0.92 secs] 
> – GC事件的持续时间, 通过三个部分来衡量: user – 在此次垃圾回收过程中, 由GC线程所消耗的总的CPU时间。 sys – GC过程中中操作系统调用和系统等待事件所消耗的时间。 real – 应用程序暂停的时间。在 Parallel GC 中, 这个数字约等于: (user time + system time)/GC线程数。 这 里使用了8个线程。 请注意,总有一定比例的处理过程是不能并行进行的。
> 

问题：0.9158801 secs和user=4.49都是GC事件持续事件，为什么差距这么大？


问题2：
老年代标记-清除-整理算法
一个说法是，依次进行标记可达对象、清除垃圾，然后将存活对象移动到一块。
另一个说法是，是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动；
然后直接清理掉端边界以外的内存；